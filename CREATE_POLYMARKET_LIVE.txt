#!/bin/bash
# Copy-paste this into your Hostinger terminal to create polymarket_live.py

cat > /root/polymarket_trading/polymarket_live.py << 'ENDFILE'
#!/usr/bin/env python3
"""
Phase 4: Live Trading Integration for Polymarket
Real-time 15-minute trading loop with hybrid strategy (mean-reversion + reversal trading)
Paper trading only - no real money at risk
"""

import json
import time
import subprocess
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import statistics
import os

# ==================== CONFIG ====================
API_BASE = "https://gamma-api.polymarket.com"
POSITION_FILE = "/root/polymarket_trading/positions.json"
TRADES_FILE = "/root/polymarket_trading/trades.json"
EQUITY_FILE = "/root/polymarket_trading/equity_live.json"

# Strategy parameters (optimized from Phase 3)
MEAN_REVERSION_CONFIG = {
    "entry_threshold": 0.40,      # Buy YES < 0.40
    "exit_threshold": 0.60,       # Sell > 0.60
    "stop_loss": 0.10,            # -10% normal markets
    "profit_target": 0.60,        # +60% mean reversion
}

REVERSAL_CONFIG = {
    "momentum_2_threshold": 0.01,  # Short-term divergence
    "momentum_10_threshold": -0.02, # Long-term weakness
    "stop_loss": 0.08,             # -8% bear markets (tight)
    "profit_target": 0.05,         # +5% quick exit
}

BANKROLL = 100.0  # Paper trading bankroll
POSITION_SIZE = 0.003  # 0.3% per position (optimized)
MIN_LIQUIDITY = 100.0
CIRCUIT_BREAKER = 3  # Stop after N consecutive losses

# ==================== MARKET DISCOVERY ====================
def get_crypto_markets() -> List[Dict]:
    """Fetch UP/DOWN crypto markets from Polymarket"""
    try:
        result = subprocess.run(
            ["curl", "-s", f"{API_BASE}/markets"],
            capture_output=True,
            text=True,
            timeout=10
        )
        all_markets = json.loads(result.stdout)
        
        # Filter for active crypto markets with liquidity
        crypto_keywords = ["BTC", "ETH", "SOL", "bitcoin", "ethereum", "solana"]
        outcome_keywords = ["up", "down", "higher", "lower", "+", "-"]
        
        crypto_markets = []
        for market in all_markets:
            # Skip closed/inactive markets
            if market.get("closed") or not market.get("active"):
                continue
            
            # Skip if no liquidity
            liquidity = float(market.get("liquidityNum", 0))
            if liquidity < MIN_LIQUIDITY:
                continue
            
            question = market.get("question", "").upper()
            
            # Check if it's a crypto market
            is_crypto = any(kw in question for kw in crypto_keywords)
            
            # Parse outcomes (might be JSON string or array)
            try:
                outcomes = market.get("outcomes", [])
                if isinstance(outcomes, str):
                    outcomes = json.loads(outcomes)
                is_binary = len(outcomes) == 2
            except:
                is_binary = False
            
            # Check if it's up/down directional
            outcome_text = " ".join([o.upper() for o in outcomes]) if outcomes else ""
            is_directional = any(kw in outcome_text for kw in outcome_keywords)
            
            if is_crypto and is_binary and is_directional:
                # Parse prices (might be JSON string or array)
                try:
                    prices = market.get("outcomePrices", [])
                    if isinstance(prices, str):
                        prices = json.loads(prices)
                    
                    # Convert string prices to float
                    prices = [float(p) for p in prices]
                    
                    market["outcomes_dict"] = {
                        o: prices[i] 
                        for i, o in enumerate(outcomes)
                    }
                    crypto_markets.append(market)
                except Exception as e:
                    pass
        
        return crypto_markets
    except Exception as e:
        print(f"Error fetching markets: {e}")
        return []

# ==================== STRATEGY LOGIC ====================
def calculate_momentum(prices: List[float], period: int) -> float:
    """Calculate momentum (ROC - Rate of Change)"""
    if len(prices) < period + 1:
        return 0.0
    return (prices[-1] - prices[-period]) / prices[-period] if prices[-period] != 0 else 0.0

def detect_market_regime(price_history: List[float]) -> str:
    """Detect market regime: bull, bear, sideways, volatile"""
    if len(price_history) < 10:
        return "unknown"
    
    recent = price_history[-10:]
    price_change = (recent[-1] - recent[0]) / recent[0]
    volatility = statistics.stdev(recent)
    
    if volatility > 0.15:
        return "volatile"
    elif price_change > 0.05:
        return "bull"
    elif price_change < -0.05:
        return "bear"
    else:
        return "sideways"

def should_enter_mean_reversion(yes_price: float, price_history: List[float]) -> Tuple[bool, str]:
    """Mean-reversion entry logic"""
    if yes_price < MEAN_REVERSION_CONFIG["entry_threshold"]:
        regime = detect_market_regime(price_history)
        if regime in ["bull", "sideways"]:
            return True, "mean_reversion"
    return False, ""

def should_enter_reversal(price_history: List[float]) -> Tuple[bool, str]:
    """Reversal trading entry logic"""
    if len(price_history) < 10:
        return False, ""
    
    momentum_2 = calculate_momentum(price_history, 2)
    momentum_10 = calculate_momentum(price_history, 10)
    
    regime = detect_market_regime(price_history)
    
    # Entry on momentum divergence in bear/volatile markets
    if (momentum_2 > REVERSAL_CONFIG["momentum_2_threshold"] and 
        momentum_10 < REVERSAL_CONFIG["momentum_10_threshold"] and
        regime in ["bear", "volatile"]):
        return True, "reversal"
    
    return False, ""

def generate_signal(market: Dict, price_history: List[float]) -> Tuple[Optional[str], str]:
    """Generate trading signal: BUY, SELL, or HOLD"""
    try:
        outcomes_dict = market.get("outcomes_dict", {})
        yes_price = outcomes_dict.get("YES", outcomes_dict.get("Up", 0.5))
        
        # Check for mean-reversion entry
        mr_entry, mr_reason = should_enter_mean_reversion(yes_price, price_history)
        if mr_entry:
            return "BUY", mr_reason
        
        # Check for reversal entry
        rev_entry, rev_reason = should_enter_reversal(price_history)
        if rev_entry:
            return "BUY", rev_reason
        
        # Exit signals (simple: if profitable or hitting stop)
        return "HOLD", ""
    
    except Exception as e:
        print(f"Error generating signal: {e}")
        return None, ""

# ==================== POSITION TRACKING ====================
def load_positions() -> Dict:
    """Load paper trading positions from file"""
    if os.path.exists(POSITION_FILE):
        try:
            with open(POSITION_FILE, 'r') as f:
                return json.load(f)
        except:
            pass
    return {
        "positions": [],
        "cash": BANKROLL,
        "equity": BANKROLL,
        "high_water": BANKROLL,
        "max_drawdown": 0.0,
        "consecutive_losses": 0,
    }

def save_positions(positions: Dict):
    """Save positions to file"""
    with open(POSITION_FILE, 'w') as f:
        json.dump(positions, f, indent=2)

def load_trades() -> List[Dict]:
    """Load trade history"""
    if os.path.exists(TRADES_FILE):
        try:
            with open(TRADES_FILE, 'r') as f:
                return json.load(f)
        except:
            pass
    return []

def save_trades(trades: List[Dict]):
    """Save trades to file"""
    with open(TRADES_FILE, 'w') as f:
        json.dump(trades, f, indent=2)

def update_position_pnl(positions: Dict, market: Dict):
    """Update P&L for open positions"""
    try:
        outcomes_dict = market.get("outcomes_dict", {})
        yes_price = outcomes_dict.get("YES", outcomes_dict.get("Up", 0.5))
        
        for position in positions["positions"]:
            if position["market_id"] == market.get("id"):
                entry_price = position["entry_price"]
                shares = position["shares"]
                
                # Calculate unrealized P&L
                current_value = shares * yes_price
                cost_basis = shares * entry_price
                unrealized_pnl = current_value - cost_basis
                unrealized_pnl_pct = unrealized_pnl / cost_basis if cost_basis != 0 else 0
                
                position["current_price"] = yes_price
                position["unrealized_pnl"] = unrealized_pnl
                position["unrealized_pnl_pct"] = unrealized_pnl_pct
                
                # Update equity
                positions["equity"] = positions["cash"] + sum(
                    p.get("unrealized_pnl", 0) for p in positions["positions"]
                )
                
                # Track drawdown
                if positions["equity"] > positions["high_water"]:
                    positions["high_water"] = positions["equity"]
                
                drawdown = (positions["high_water"] - positions["equity"]) / positions["high_water"]
                if drawdown > positions["max_drawdown"]:
                    positions["max_drawdown"] = drawdown
    
    except Exception as e:
        print(f"Error updating position P&L: {e}")

def execute_trade(positions: Dict, market: Dict, signal: str, strategy: str) -> bool:
    """Execute a trade signal"""
    try:
        if signal != "BUY":
            return False
        
        # Check circuit breaker
        if positions["consecutive_losses"] >= CIRCUIT_BREAKER:
            print(f"‚õî Circuit breaker active ({CIRCUIT_BREAKER} losses). Skipping trade.")
            return False
        
        # Check available cash
        outcomes_dict = market.get("outcomes_dict", {})
        yes_price = outcomes_dict.get("YES", outcomes_dict.get("Up", 0.5))
        
        position_amount = positions["cash"] * POSITION_SIZE
        shares = position_amount / yes_price
        
        if position_amount > positions["cash"]:
            print(f"Insufficient cash: need ${position_amount:.2f}, have ${positions['cash']:.2f}")
            return False
        
        # Create position
        position = {
            "market_id": market.get("id"),
            "market_question": market.get("question"),
            "entry_time": datetime.now().isoformat(),
            "entry_price": yes_price,
            "shares": shares,
            "amount": position_amount,
            "strategy": strategy,
            "current_price": yes_price,
            "unrealized_pnl": 0.0,
            "unrealized_pnl_pct": 0.0,
        }
        
        # Set appropriate stop loss and profit target
        if strategy == "reversal":
            position["stop_loss_pct"] = REVERSAL_CONFIG["stop_loss"]
            position["profit_target_pct"] = REVERSAL_CONFIG["profit_target"]
        else:
            position["stop_loss_pct"] = MEAN_REVERSION_CONFIG["stop_loss"]
            position["profit_target_pct"] = MEAN_REVERSION_CONFIG["profit_target"]
        
        positions["positions"].append(position)
        positions["cash"] -= position_amount
        
        trade = {
            "timestamp": datetime.now().isoformat(),
            "type": "BUY",
            "market": market.get("question"),
            "strategy": strategy,
            "price": yes_price,
            "shares": shares,
            "amount": position_amount,
            "position_id": len(positions["positions"]) - 1,
        }
        
        trades = load_trades()
        trades.append(trade)
        save_trades(trades)
        
        print(f"‚úÖ BUY: {market.get('question', 'Unknown')[:50]} @ {yes_price:.3f}, {shares:.1f} shares, ${position_amount:.2f} ({strategy})")
        return True
    
    except Exception as e:
        print(f"Error executing trade: {e}")
        return False

def check_exit_conditions(positions: Dict, market: Dict) -> Tuple[bool, str]:
    """Check if any positions should be closed"""
    try:
        for i, position in enumerate(positions["positions"]):
            if position["market_id"] != market.get("id"):
                continue
            
            pnl_pct = position["unrealized_pnl_pct"]
            
            # Check profit target
            if pnl_pct >= position["profit_target_pct"]:
                return True, f"profit_target ({pnl_pct:.2%})"
            
            # Check stop loss
            if pnl_pct <= -position["stop_loss_pct"]:
                return True, f"stop_loss ({pnl_pct:.2%})"
        
        return False, ""
    
    except Exception as e:
        print(f"Error checking exits: {e}")
        return False, ""

def close_position(positions: Dict, market: Dict, exit_reason: str) -> bool:
    """Close an open position"""
    try:
        outcomes_dict = market.get("outcomes_dict", {})
        yes_price = outcomes_dict.get("YES", outcomes_dict.get("Up", 0.5))
        
        for i, position in enumerate(positions["positions"]):
            if position["market_id"] == market.get("id"):
                realized_pnl = position["unrealized_pnl"]
                sell_amount = position["shares"] * yes_price
                
                # Update cash and metrics
                positions["cash"] += sell_amount
                positions["consecutive_losses"] = 0 if realized_pnl > 0 else positions["consecutive_losses"] + 1
                
                trade = {
                    "timestamp": datetime.now().isoformat(),
                    "type": "SELL",
                    "market": market.get("question"),
                    "price": yes_price,
                    "shares": position["shares"],
                    "amount": sell_amount,
                    "realized_pnl": realized_pnl,
                    "realized_pnl_pct": position["unrealized_pnl_pct"],
                    "exit_reason": exit_reason,
                    "position_id": i,
                }
                
                trades = load_trades()
                trades.append(trade)
                save_trades(trades)
                
                pnl_emoji = "‚úÖ" if realized_pnl > 0 else "‚ùå"
                print(f"{pnl_emoji} SELL: {market.get('question', 'Unknown')[:50]} @ {yes_price:.3f}, P&L: ${realized_pnl:.2f} ({position['unrealized_pnl_pct']:.2%}) [{exit_reason}]")
                
                positions["positions"].pop(i)
                return True
        
        return False
    
    except Exception as e:
        print(f"Error closing position: {e}")
        return False

# ==================== MAIN TRADING LOOP ====================
def run_trading_cycle(price_history_cache: Dict) -> Dict:
    """Run one complete 15-minute trading cycle"""
    print(f"\n{'='*60}")
    print(f"Trading Cycle: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*60}")
    
    positions = load_positions()
    markets = get_crypto_markets()
    
    if not markets:
        print("No crypto markets found. Skipping cycle.")
        return positions
    
    # Limit to top 5 most liquid markets
    markets = sorted(markets, key=lambda m: m.get("liquidity", 0), reverse=True)[:5]
    
    for market in markets:
        market_id = market.get("id")
        
        # Initialize price history for market
        if market_id not in price_history_cache:
            price_history_cache[market_id] = []
        
        # Get current price
        outcomes_dict = market.get("outcomes_dict", {})
        yes_price = outcomes_dict.get("YES", outcomes_dict.get("Up", 0.5))
        price_history_cache[market_id].append(yes_price)
        
        # Keep last 20 prices
        if len(price_history_cache[market_id]) > 20:
            price_history_cache[market_id] = price_history_cache[market_id][-20:]
        
        # Update P&L for existing positions
        update_position_pnl(positions, market)
        
        # Check exit conditions for existing positions
        should_exit, exit_reason = check_exit_conditions(positions, market)
        if should_exit:
            close_position(positions, market, exit_reason)
        
        # Generate new signals only if no existing position in this market
        has_position = any(p["market_id"] == market_id for p in positions["positions"])
        if not has_position:
            signal, strategy = generate_signal(market, price_history_cache[market_id])
            if signal:
                execute_trade(positions, market, signal, strategy)
        
        print(f"  {market.get('question', 'Unknown')[:50]}: ${yes_price:.3f}")
    
    # Save updated positions
    positions["equity"] = positions["cash"] + sum(
        p.get("unrealized_pnl", 0) for p in positions["positions"]
    )
    save_positions(positions)
    
    # Log equity snapshot
    equity_log = {
        "timestamp": datetime.now().isoformat(),
        "cash": positions["cash"],
        "equity": positions["equity"],
        "positions_count": len(positions["positions"]),
        "max_drawdown": positions["max_drawdown"],
    }
    
    if os.path.exists(EQUITY_FILE):
        try:
            with open(EQUITY_FILE, 'r') as f:
                equity_history = json.load(f)
        except:
            equity_history = []
    else:
        equity_history = []
    
    equity_history.append(equity_log)
    with open(EQUITY_FILE, 'w') as f:
        json.dump(equity_history, f, indent=2)
    
    print(f"\nPortfolio: Cash=${positions['cash']:.2f}, Equity=${positions['equity']:.2f}, Max DD={positions['max_drawdown']:.2%}")
    
    return positions

# ==================== ENTRY POINT ====================
if __name__ == "__main__":
    print("üöÄ Polymarket Live Trading System - Phase 4")
    print(f"Bankroll: ${BANKROLL:.2f}, Position Size: {POSITION_SIZE:.2%}")
    
    price_history_cache = {}
    
    try:
        # Run single cycle for testing
        run_trading_cycle(price_history_cache)
        print("\n‚úÖ Cycle completed successfully")
    
    except KeyboardInterrupt:
        print("\n‚õî Trading stopped by user")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
ENDFILE

echo "‚úÖ polymarket_live.py created!"
